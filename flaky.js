// Based on information about performance from:
// http://blog.mikemccandless.com/2014/05/choosing-fast-unique-identifier-uuid.html

var charSets = {
  base64: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  base64URL: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
};

var crypto = require('crypto'),
    os = require('os');

// Distribution
// We need 42 bits for the timestamp. That leaves 22 bits - 8 for the sequence and 14 for the node id.
var nodeIdSize = 14,
    seqSize = 22 - nodeIdSize;

// Hash the hostname to hex, grab the first 14 bits of the hash (making the node id unique to the system)
// and XOR a random number between 0 and 14 to account for multiple instances on the same system.
// Note that we use XOR to make sure we only touch the last few (up to 4) bits and prevent changing the length
// of the binary string.
//
// Also, the random range is based on:
// https://stackoverflow.com/questions/1527803/generating-random-numbers-in-javascript-in-a-specific-range#1527820
var nodeIdBits = parseInt(crypto.createHash('md5').update(os.hostname()).digest('hex'), 16).toString(2).substr(0, nodeIdSize);
nodeIdBits = (parseInt(nodeIdBits, 2) ^ (Math.random() * (nodeIdSize + 1) | 0)).toString(2);

// Potential collisions:
//
// It is important to update the base time somewhat frequently to prevent a potential collision. If there are multiple server
// instances running and they each start at the same time then the node id may be the only thing preventing a collision.
// However, we have no idea what the actual binary distance between any two node ids is and it's fairly harmless to update
// the base timestamp every once in a while, effectively resetting the whole namespace.
// If there are more ids generated by a single instance than the distance between any two node ids before the base time is
// updated for two nodes with the same base time then there most would be a collision.
//
// To help mitigate that possibility somewhat, after each iteration of the 8 bit 256 number sequence, the base time will be
// bumped by a random, predetermined time step of between 1 and 9 (inclusive) milliseconds. Additionally, the base time will
// be completely reset after every 100,000 ids that are generated.

var baseTime, baseTimeBits,
    baseTimeStep = Math.random() * (10 - 1) + 1 | 0,
    seq = 0,
    seqSize = 1 << 8,
    maxGenPerTime = 100000,
    genCount = 0,
    idBuffer = new Buffer(11);

function padLeft(str, length, val) {
  while(str.length < length) {
    str = val + str;
  }

  return str;
}

function updateBaseTime() {
  // Note that we pad to 44 bits because when the binary string gets chunked we need it to divide evenly by 6 with the
  // LSB fully packed for proper base64 encoding.

  baseTime = Date.now();
  baseTimeBits = padLeft(baseTime.toString(2), 44, '0');
  genCount = 0;
}

// See http://jsperf.com/chunk-string
function chunkSubstr(str, size) {
  var numChunks = str.length / size + .5 | 0,
      chunks = new Array(numChunks);

  for(var i = 0, o = 0; i < numChunks; ++i, o += size) {
    chunks[i] = str.substr(o, size);
  }

  return chunks;
}

function genBufferId() {
  ++genCount;

  if(seq === seqSize || genCount === maxGenPerTime) {
    baseTime += baseTimeStep;
    // See note in `updateBaseTime()` about 44 bit length
    baseTimeBits = padLeft(baseTime.toString(2), 44, '0');
    seq = 0;
  }

  if(genCount === maxGenPerTime) {
    updateBaseTime();
  }

  var seqBits = (seqSize | seq++).toString(2).substr(1),
      binStr = baseTimeBits + nodeIdBits + seqBits,
      byteChunks = chunkSubstr(binStr, 6);

  for(var i = 0; i < byteChunks.length; ++i) {
    idBuffer.writeUInt8(parseInt(byteChunks[i], 2), i);
  }

  return idBuffer;
}


updateBaseTime();

module.exports = {
  updateBaseTime: updateBaseTime,
  bufferId: genBufferId,

  base64Id: function base64Id(charSet) {
    var buffer = genBufferId();

    var encoded = '',
        chars =  charSet && charSet.length == 64 ? charSet : charSets[charSet || 'base64URL'];
    for(var j = 0; j < buffer.length; ++j) {
      encoded += chars[buffer[j]];
    }

    return encoded;
  }
};